import group_theory.quotient_group
import ring_theory.dedekind_domain

open ring
open ring.fractional_ideal

section integral_domain

variables {R K L : Type*} [integral_domain R]
variables [field K] [field L] [decidable_eq L]
variables (f : fraction_map R K)
variables [algebra f.codomain L] [finite_dimensional f.codomain L]
variables [algebra R L] [is_scalar_tower R f.codomain L]

open ring.fractional_ideal units

section
/-- `to_principal_ideal x` sends `x ≠ 0 : K` to the fractional ideal generated by `x` -/
@[irreducible]
def to_principal_ideal : units f.codomain →* units (fractional_ideal f) :=
{ to_fun := λ x,
  ⟨ span_singleton x,
    span_singleton x⁻¹,
    by simp only [span_singleton_one, units.mul_inv', span_singleton_mul_span_singleton],
    by simp only [span_singleton_one, units.inv_mul', span_singleton_mul_span_singleton]⟩,
  map_mul' := λ x y, ext (by simp only [units.coe_mk, units.coe_mul, span_singleton_mul_span_singleton]),
  map_one' := ext (by simp only [span_singleton_one, units.coe_mk, units.coe_one]) }

local attribute [semireducible] to_principal_ideal

variables {f}

@[simp] lemma coe_to_principal_ideal (x : units f.codomain) :
  (to_principal_ideal f x : fractional_ideal f) = span_singleton x :=
rfl

@[simp] lemma to_principal_ideal_eq_iff {I : units (fractional_ideal f)} {x : units f.codomain} :
  to_principal_ideal f x = I ↔ span_singleton (x : f.codomain) = I :=
units.ext_iff

end

instance principal_ideals.normal : (to_principal_ideal f).range.normal :=
subgroup.normal_of_comm _

section
/-- The class group with respect to `f : fraction_map R K`
is the group of invertible fractional ideals modulo the principal ideals. -/
@[derive(comm_group)]
def class_group := quotient_group.quotient (to_principal_ideal f).range

@[simp] lemma fractional_ideal.coe_to_fractional_ideal_top :
  ((⊤ : ideal R) : fractional_ideal f) = 1 :=
by { rw [← ideal.one_eq_top], refl }

@[simp] lemma units.mk0_one {M : Type*} [group_with_zero M] (h) :
  units.mk0 (1 : M) h = 1 :=
by { ext, refl }

@[simp] lemma units.mk0_map {M : Type*} [group_with_zero M] (x y : M) (hxy) :
  mk0 (x * y) hxy = mk0 x (mul_ne_zero_iff.mp hxy).1 * mk0 y (mul_ne_zero_iff.mp hxy).2 :=
by { ext, refl }

/-- The monoid of nonzero ideals. -/
def nonzero_ideal (R : Type*) [integral_domain R] : submonoid (ideal R) :=
{ carrier := {I | I ≠ ⊥},
  one_mem' := show (1 : ideal R) ≠ ⊥, by { rw ideal.one_eq_top, exact submodule.bot_ne_top.symm },
  mul_mem' := λ I J (hI : I ≠ ⊥) (hJ : J ≠ ⊥), show I * J ≠ ⊥,
    by { obtain ⟨x, x_mem, x_ne⟩ := I.ne_bot_iff.mp hI,
         obtain ⟨y, y_mem, y_ne⟩ := J.ne_bot_iff.mp hJ,
         exact (submodule.ne_bot_iff _).mpr
           ⟨x * y, ideal.mul_mem_mul x_mem y_mem, mul_ne_zero x_ne y_ne⟩ } }

/-- Send a nonzero ideal to the corresponding class in the class group. -/
noncomputable def class_group.mk0 [is_dedekind_domain R] :
  nonzero_ideal R →* class_group f :=
(quotient_group.mk' _).comp
  { to_fun := λ I, units.mk0 I
      ((fractional_ideal.coe_to_fractional_ideal_ne_zero (le_refl (non_zero_divisors R))).mpr I.2),
    map_one' := by simp,
    map_mul' := λ x y, by simp }

lemma quotient_group.mk'_eq_mk' {G : Type*} [group G] {N : subgroup G} [hN : N.normal] {x y : G} :
  quotient_group.mk' N x = quotient_group.mk' N y ↔ ∃ z ∈ N, x * z = y :=
(@quotient.eq _ (quotient_group.left_rel _) _ _).trans
  ⟨λ (h : x⁻¹ * y ∈ N), ⟨_, h, by rw [← mul_assoc, mul_right_inv, one_mul]⟩,
   λ ⟨z, z_mem, eq_y⟩,
     by { rw ← eq_y, show x⁻¹ * (x * z) ∈ N, rwa [← mul_assoc, mul_left_inv, one_mul] }⟩

lemma ideal.mem_mul_span_singleton {x y : R} {I : ideal R} :
  x ∈ I * ideal.span {y} ↔ ∃ z ∈ I, z * y = x :=
submodule.mem_smul_span_singleton

lemma ideal.mem_span_singleton_mul {x y : R} {I : ideal R} :
  x ∈ ideal.span {y} * I ↔ ∃ z ∈ I, y * z = x :=
by simp only [mul_comm, ideal.mem_mul_span_singleton]

lemma ideal.le_span_singleton_mul_iff {x : R} {I J : ideal R} :
  I ≤ ideal.span {x} * J ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI :=
show (∀ {zI} (hzI : zI ∈ I), zI ∈ ideal.span {x} * J) ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI,
by simp only [ideal.mem_span_singleton_mul]

lemma ideal.span_singleton_mul_le_iff {x : R} {I J : ideal R} :
  ideal.span {x} * I ≤ J ↔ ∀ z ∈ I, x * z ∈ J :=
begin
  simp only [ideal.mul_le, ideal.mem_span_singleton_mul, ideal.mem_span_singleton],
  split,
  { intros h zI hzI,
    exact h x (dvd_refl x) zI hzI },
  { rintros h _ ⟨z, rfl⟩ zI hzI,
    rw [mul_comm x z, mul_assoc],
    exact J.mul_mem_left (h zI hzI) },
end

lemma ideal.span_singleton_mul_le_span_singleton_mul {x y : R} {I J : ideal R} :
  ideal.span {x} * I ≤ ideal.span {y} * J ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zI = y * zJ :=
by simp only [ideal.span_singleton_mul_le_iff, ideal.mem_span_singleton_mul, eq_comm]

lemma ideal.eq_singleton_mul {x : R} (I J : ideal R) :
  I = ideal.span {x} * J ↔ ((∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI) ∧ (∀ z ∈ J, x * z ∈ I)) :=
by simp only [le_antisymm_iff, ideal.le_span_singleton_mul_iff, ideal.span_singleton_mul_le_iff]

lemma ideal.singleton_mul_eq_singleton_mul {x y : R} (I J : ideal R) :
  ideal.span {x} * I = ideal.span {y} * J ↔
    ((∀ zI ∈ I, ∃ zJ ∈ J, x * zI = y * zJ) ∧
     (∀ zJ ∈ J, ∃ zI ∈ I, x * zI = y * zJ)) :=
by simp only [le_antisymm_iff, ideal.span_singleton_mul_le_span_singleton_mul, eq_comm]

lemma fractional_ideal.le_span_singleton_mul_iff {x : f.codomain} {I J : fractional_ideal f} :
  I ≤ span_singleton x * J ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI :=
show (∀ {zI} (hzI : zI ∈ I), zI ∈ span_singleton x * J) ↔ ∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI,
by { simp only [fractional_ideal.mem_singleton_mul, eq_comm], refl }

lemma fractional_ideal.span_singleton_mul_le_iff {x : f.codomain} {I J : fractional_ideal f} :
  span_singleton x * I ≤ J ↔ ∀ z ∈ I, x * z ∈ J :=
begin
  simp only [fractional_ideal.mul_le, fractional_ideal.mem_singleton_mul,
             fractional_ideal.mem_span_singleton],
  split,
  { intros h zI hzI,
    exact h x ⟨1, one_smul _ _⟩ zI hzI },
  { rintros h _ ⟨z, rfl⟩ zI hzI,
    rw [algebra.smul_mul_assoc],
    exact submodule.smul_mem J.1 _ (h zI hzI) },
end

lemma fractional_ideal.eq_span_singleton_mul {x : f.codomain} {I J : fractional_ideal f} :
  I = span_singleton x * J ↔ (∀ zI ∈ I, ∃ zJ ∈ J, x * zJ = zI) ∧ ∀ z ∈ J, x * z ∈ I :=
by simp only [le_antisymm_iff, fractional_ideal.le_span_singleton_mul_iff,
              fractional_ideal.span_singleton_mul_le_iff]

lemma class_group.mk0_eq_mk0_iff [is_dedekind_domain R]
  (I J : nonzero_ideal R) :
  class_group.mk0 f I = class_group.mk0 f J ↔
    ∃ (x y : R) (hx : x ≠ 0) (hy : y ≠ 0), ideal.span {x} * (I : ideal R) = ideal.span {y} * J :=
begin
  simp only [class_group.mk0, monoid_hom.comp_apply, monoid_hom.coe_mk, quotient_group.mk'_eq_mk',
    exists_prop, monoid_hom.mem_range, ideal.singleton_mul_eq_singleton_mul],
  split,
  { rintros ⟨z, ⟨xy, hxy, rfl⟩, eq_J⟩,
    have : (J : fractional_ideal f) = (span_singleton xy * I),
    { simpa only [mul_comm, eq_comm, coe_mk0, monoid_hom.to_fun_eq_coe, coe_to_principal_ideal,
                  units.coe_mul]
        using congr_arg (coe : _ → fractional_ideal f) eq_J },
    obtain ⟨hJI, hIJ⟩ := (fractional_ideal.eq_span_singleton_mul _).mp this,
    have hx : (f.to_localization_map.sec (xy : f.codomain)).1 ≠ 0,
    { suffices : f.to_map (f.to_localization_map.sec (xy : f.codomain)).1 ≠ 0,
      { refine mt (λ h, _) this,
        rw [h, ring_hom.map_zero] },
      rw [ne.def, ← localization_map.sec_spec (xy : f.codomain), mul_eq_zero],
      push_neg,
      use xy.ne_zero,
      exact f.to_map_ne_zero_of_mem_non_zero_divisors _ },
    use [(f.to_localization_map.sec (xy : f.codomain)).1,
         (f.to_localization_map.sec (xy : f.codomain)).2,
         hx,
         non_zero_divisors.ne_zero_of_mem (f.to_localization_map.sec (xy : f.codomain)).2.2],
    have x_eq : (xy * f.to_map (f.to_localization_map.sec (xy : f.codomain)).2 : f.codomain) =
        f.to_map (f.to_localization_map.sec (xy : f.codomain)).1 :=
      localization_map.sec_spec (xy : f.codomain),
    split,
    { intros zI hzI,
      obtain ⟨zJ, hzJ, (zJ_eq : f.to_map zJ = _ * f.to_map _)⟩ := hIJ (f.to_map zI) _,
      { use [zJ, hzJ],
        apply f.injective,
        rw [f.to_map.map_mul, f.to_map.map_mul, zJ_eq, ← x_eq],
        ac_refl },
      { simpa only [exists_prop, mem_coe_ideal, exists_mem_to_map_eq, coe_coe] using hzI } },
    { intros zJ hzJ,
      obtain ⟨zI', hzI', eq_zJ⟩ := hJI (f.to_map zJ) _,
      obtain ⟨zI, hzI, rfl⟩ := fractional_ideal.mem_coe_ideal.mp hzI',
      { use [zI, hzI],
        apply f.injective,
        rw [f.to_map.map_mul, f.to_map.map_mul, ← eq_zJ, ← x_eq],
        ac_refl },
      { simpa only [exists_prop, mem_coe_ideal, exists_mem_to_map_eq, coe_coe] using hzJ } } },
  { rintros ⟨x, y, hx, hy, hIJ, hJI⟩,
    have hy' := mem_non_zero_divisors_iff_ne_zero.mpr hy,
    refine ⟨_, ⟨units.mk0 (f.mk' x ⟨y, hy'⟩) _, rfl⟩, _⟩,
    { rw [ne.def, f.mk'_eq_iff_eq_mul, zero_mul],
      exact mt (f.to_map.injective_iff.mp f.injective _) hx },
    suffices : (J : fractional_ideal f) = span_singleton (f.mk' x ⟨y, _⟩) * I,
    { apply units.ext,
      simpa only [mul_comm, eq_comm, coe_mk0, coe_to_principal_ideal, units.coe_mul] using this },
    refine (fractional_ideal.eq_span_singleton_mul _).mpr ⟨_, _⟩,
    { intros zJ' hzJ',
      obtain ⟨zJ, hzJ, rfl⟩ := mem_coe_ideal.mp hzJ',
      obtain ⟨zI, hzI, x_mul_eq_y_mul⟩ := hJI zJ hzJ,
      refine ⟨f.to_map zI, mem_coe_ideal.mpr ⟨zI, hzI, rfl⟩, _⟩,
      apply mul_left_cancel' (f.to_map_ne_zero_of_mem_non_zero_divisors ⟨y, hy'⟩),
      rw [← mul_assoc, localization_map.mk'_spec', ← ring_hom.map_mul, ← ring_hom.map_mul,
          x_mul_eq_y_mul, subtype.coe_mk] },
    { intros zI' hzI',
      obtain ⟨zI, hzI, rfl⟩ := mem_coe_ideal.mp hzI',
      obtain ⟨zJ, hzJ, x_mul_eq_y_mul⟩ := hIJ zI hzI,
      refine mem_coe_ideal.mpr ⟨zJ, hzJ, _⟩,
      apply mul_left_cancel' (f.to_map_ne_zero_of_mem_non_zero_divisors ⟨y, hy'⟩),
      rw [← mul_assoc, localization_map.mk'_spec', ← ring_hom.map_mul, ← ring_hom.map_mul,
          x_mul_eq_y_mul, subtype.coe_mk] } },
end
.

lemma class_group.mk0_surjective [is_dedekind_domain R] : function.surjective (class_group.mk0 f) :=
begin
  rintros ⟨I⟩,
  obtain ⟨a, a_ne_zero', ha⟩ := I.1.2,
  have a_ne_zero := non_zero_divisors.ne_zero_of_mem a_ne_zero',
  have fa_ne_zero : f.to_map a ≠ 0 := f.to_map_ne_zero_of_mem_non_zero_divisors ⟨a, a_ne_zero'⟩,
  refine ⟨⟨{ carrier := { x | (f.to_map a)⁻¹ * f.to_map x ∈ I.1 }, .. }, _⟩, _⟩,
  { simp only [ring_hom.map_zero, set.mem_set_of_eq, mul_zero, ring_hom.map_mul],
    exact submodule.zero_mem I },
  { simp only [ring_hom.map_add, set.mem_set_of_eq, mul_zero, ring_hom.map_mul, mul_add],
    exact λ _ _ ha hb, submodule.add_mem I ha hb },
  { simp only [smul_eq_mul, set.mem_set_of_eq, mul_zero, ring_hom.map_mul, mul_add,
               mul_left_comm (f.to_map a)⁻¹],
    exact λ c _ hb, submodule.smul_mem I c hb },
  { apply (submodule.ne_bot_iff _).mpr,
    obtain ⟨x, x_ne, x_mem⟩ := exists_ne_zero_mem_is_integer I.ne_zero,
    refine ⟨a * x, show (f.to_map a)⁻¹ * f.to_map (a * x) ∈ I.1, from _, mul_ne_zero a_ne_zero x_ne⟩,
    { rwa [ring_hom.map_mul, ← mul_assoc, inv_mul_cancel fa_ne_zero, one_mul] } },
  { symmetry,
    apply quotient.sound,
    refine ⟨units.mk0 (f.to_map a) fa_ne_zero, _⟩,
    apply @mul_left_cancel _ _ I,
    rw [← mul_assoc, mul_right_inv, one_mul, eq_comm, mul_comm I],
    simp only [monoid_hom.coe_mk, subtype.coe_mk, ring_hom.map_mul, coe_coe],
    apply units.ext,
    simp only [units.coe_mul, coe_to_principal_ideal, coe_mk0, fractional_ideal.eq_span_singleton_mul],
    split,
    { intros zJ' hzJ',
      obtain ⟨zJ, hzJ : (f.to_map a)⁻¹ * f.to_map zJ ∈ (I : fractional_ideal f), rfl⟩ := mem_coe_ideal.mp hzJ',
      refine ⟨_, hzJ, _⟩,
      rw [← mul_assoc, mul_inv_cancel fa_ne_zero, one_mul] },
    { intros zI' hzI',
      rw mem_coe_ideal,
      obtain ⟨y, hy⟩ := ha zI' hzI',
      refine ⟨y, _, hy⟩,
      show (f.to_map a)⁻¹ * f.to_map y ∈ (I : fractional_ideal f),
      rwa [hy, ← mul_assoc, inv_mul_cancel fa_ne_zero, one_mul] } }
end

end

end integral_domain
